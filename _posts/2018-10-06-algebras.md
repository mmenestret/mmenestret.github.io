---
layout: post
title: "Anatomy of an algebra"
author: "Myself"
date: 2018-10-06
tags: [Scala, Functional programming]
---

I will try to group here, in an anatomy atlas, basic notions of functional programming that I find myself explaining often lately into a series of articles.

The idea here is to have a place to point people needing explanations and to increase my own understanding of these subjects by trying to explain them the best I can.
I'll try to focus more on making the reader feel an intuition, a feeling about the concepts rather than on the perfect, strict correctness of my explanations.

- Part 1: [Anatomy of an algebra]({{ site.baseurl }}{% link _posts/2018-10-06-algebras.md %})
- Part 2: [Anatomy of a type class]({{ site.baseurl }}{% link _posts/2018-10-05-typeclasses.md %})
- Part 3: Anatomy of semi groups and monoids - Not yet written
- Part 4: Anatomy of functors, applicatives and monads - Not written yet
- Part 5: Anatomy of the tagless final encoding - Not written yet

# What is an alegra

Functional programmers tend to talk a lot about _algebras_, so a good starting point would be to understand what an _algebra_ is.
A simple definition would be (from _Wikipedia_):

> In its most general form, an _algebra_ is the study of mathematical symbols and the rules for manipulating these symbols

Then to rephrase it in simpler terms, it is a system formed by:

- __Symbols__, items or "things"
- __Operations__ on thoses "things"
- __Properties and rules__ about those operations

A simple _algebra_ example would be:

- Symbols: the integer numbers
- Operations: addition and multiplication
- [Properties and rules](https://en.wikipedia.org/wiki/Integer#Algebraic_properties):
    - Closure: the result of the two operations is itself in integer number
    - Associativity: `a + (b + c) = (a + b) + c` and `a × (b × c) = (a × b) × c`
    - Commutativity: `a + b = b + a` and `a × b = b × a`
    - Identity elements: `a + 0 = a` and `a * 1 = a`
    - And so on (check the link if you want to see the rest)

# What's the relation about what we do in FP and Algebras ?

## Domain modeling

When modeling a business domain, in functional programming, [we separate strongly data from behaviors]({{ site.baseurl }}{% link _posts/2018-10-05-typeclasses.md %})(see the _Data/behavior relationship_ section).

To do that:

- We create types on one side
- Pure functions manipulating those types
- And these functions have to respect some strict business logic

Doesn't that ring any bell ?

We manipulate _algebras_ !

- __Symbols__: our business types
- __Operations__: our business function acting on those types
- __Properties and rules__: our business logic implemented in these functions, and our _property based tests_
    - We won't cover those here, but to give you an idea, these are not unit tests, but tests based on function properties that they must _always_ verify (such as: "A combination of several sales cannot result in a negative price") while tested against a wide range of more or less random values generated by a test framework

## A concrete example

To make it clearer, let's take a dummy example.

Say we have to produce sales reports, we would probably model our domain like:

```scala
type Amount = Int
type Price = Int

final class ID(val value: Int) extends AnyVal
final case class Item(id: ID, price: Price)
final case class Sales(items: List[(ID, Amount)], totalPrice: Price)
  
trait SalesOperations {
    def combineAll(sales: List[Sales]): Sales
    def generateReport(sales: Sales): String
}
```

In that case:

- __Symbols__: `Amount`, `Price`, `ID`, `Item`, `Sales`, etc. (our business types)
- __Operations__: `combineAll`, `generateReport` (operations on those types)
- __Properties and rules__: the business logic and the tests we haven't implemented here

That's pretty much it !

It happens frequently that shared behaviors that are common to several types.
We want to be able to design functions that can be run on those different types and have the expected behavior depending on its input types. That functions are said then said to be _polymorphic_.

That's a problem we solve with [_type classes_]({{ site.baseurl }}{% link _posts/2018-10-05-typeclasses.md %}).

# And what about these ADTs ?

_ADT_ stands for _algebraïc data type_, and that's the definition of an _algebraïc data type_:

> In computer programming, especially functional programming and type theory, an _algebraic data type_ is a kind of composite type, i.e., a type formed by combining other types.

We call these new types _ADTs_ because we create them by combining existing types... well, guess what ? We use an _algebra_ again !

This is algebra is the following:

- __Symbols__: existing types (primitive types, other existing ADTs, ...)
- __Operations__: _sum_ and _product_ (we'll see what they mean)
- __Properties and rules__: some properties and laws about these _sum_ and _product_ operations that we are also going to see

## Sum

_sum_ is the action of combining two or more types by summing them together.

You can see it as a way to define that __a value of a _sum type_ can only be: either a value of this OR that type__.

It is done, in _Scala_, usually by using:

- _sealed traits_ and their instances as _case classes_ or _case objects_

Or less often:

- The `Either[A, B]` type

That way, when you declare:

```scala
sealed trait CoinSide
case object Heads extends CoinSide
case object Tails extends CoinSide
```

You are creating an _ADT_ `CoinSide` which is a _sum type_ (created with a _sum_ operation) which has two and only two possible values (or inhabitants), `Heads` or `Tails`.

The same would be achieved with:

```scala
type CoinSide = Either[Heads, Tails]
```

Whose possible values would then be, `Left(Heads)` or `Right(Tails)` which is two different encodings for the same meaning.

## Sum properties

The _sum_ operation also have properties. I won't go into full details here but (these examples would equally be true with _sealed traits_ + their implementations instead of `Either` type):

- The number of values of a _sum type_ is the _sum_ of the values of its composing types members (just as you would assume for addition on integers)
    - `Boolean` has __two__ inhabitants: `true` and `false`
    - `Either[Boolean, Boolean]` which is a _sum type_ of two types `Boolean` has __four inhabitants__:
        - `Left(true)`
        - `Left(false)`
        - `Right(true)`
        - `Right(false)`
    - `Either[Boolean, Either[Boolean, Boolean]]]` is a _sum type_ between a `Boolean` and another _sum type_ of a `Boolean` and a `Boolean`
        - Well guess what ? It has 2 + (2 + 2) values !
- It has an _identity_ element which is the `Nothing` type which has no values at all
    - `Either[Boolean, Nothing]` is a _sum type_ of a `Boolean` with the _sum_ identity. Because there is no way to create a value of type `Nothing`, it does not exist, so there is no way to construct a `Right`, it has only __two values__:
        - `Left(true)`
        - `Left(false)`
- It is associative, `Either[Boolean, Either[Boolean, Boolean]]]` is the same as `Either[Either[Boolean, Boolean]],Boolean]`, you can enumerate the values, you'll see (well _isomorphic_ but let's say they are the same) !
- And so on (I'll give you more material at the end if you want to keep diving)

## Product

_product_ is the action of combining two or more types together by multiplying them.

You can see it as a way to define that __a value of a _product type_ is a combination of values of this AND that type__.

It is done, in _Scala_ usually by using:

- _case classes_

Or less often

- _tuples_

That way, when you declare:

```scala
case class TwoCoins(fst: CoinSide, snd: CoinSide)
// or
type TwoCoins = (CoinSide, CoinSide)
```

You are creating an _ADT_ `TwoCoins` which is a _product types_ (created with a _product_ operation) which has the number of values of its members multiplied.

In our case 4 values (2 * 2):

- `TwoCoins(Heads, Heads)` or `(Heads, Heads)`
- `TwoCoins(Heads, Tails)` or `(Heads, Tails)`
- `TwoCoins(Tails, Heads)` or `(Tails, Heads)`
- `TwoCoins(Tails, Tails)` or `(Tails, Tails)`

You can observe that _product types_ values are the cartesian product of their composing types values !

## Product properties

The _product_ operation also have properties. I won't go into full details here but (these example would equally be true with _case classes_ instead of _tuples_):

- The number of values of a _product types_ is the _product_ of the number of the values of its combining members (as you would assume for multiplication on integers)
    - `Boolean` has __two__ inhabitants: `true` and `false`
    - `(Boolean, Boolean)` which is a _product type_ of two types `Boolean` has __four values__:
        - `(true, true)`
        - `(true, false)`
        - `(false, true)`
        - `(false, false)`
    - `(Boolean, (Boolean, Boolean)` is a _product type_ between a `Boolean` and another _product type_ of a `Boolean` and a `Boolean`
        - Well guess what ? It has 2 * (2 * 2) values !
- It has an _identity_ which is the famous `Unit` type which has only one inhabitant, the value `()`
    - `(Boolean, Unit)` is a _product type_ of a `Boolean` with the _product_ identity. It has __two values__:
        - `(true, ())`
        - `(false, ())`
- It is associative, `(Boolean, (Boolean, Boolean)` is the same as `((Boolean, Boolean),Boolean)`, you can enumerate the values, you'll see (well _isomorphic_ but let's say they are the same) !
- And so on (I'll give you more material at the end if you want to keep diving)

## Mixed types

Of course, as we saw in some of the examples, _ADTs_ can be combinations of other _ADTs_, such as _sum of products_, _products of sums_, _product of products_ and so on.

# More material

If you want to keep diving deeper, some interesting stuff can be found on my [FP resources list](https://github.com/mmenestret/fp-ressources) and in particular:

- [Functional and Reactive Domain Modeling](https://www.manning.com/books/functional-and-reactive-domain-modeling)(An awesome book about functional domain modeling using _algebras_)
- [Kinds of types in Scala](https://kubuszok.com/compiled/kinds-of-types-in-scala/)
- [Why do Functional Programmers always talk about Algebra(s)?](https://www.youtube.com/watch?v=s2ay9nEW3ak)

# Conclusion

All that long digression was only meant to show you that, __creating new composite data types the way we saw is done by using an algebra__ (that we just described).

That's why these composite types are called _Algebraïc Data Types_ :).

To sum up, we learnt:

- What was an _algebra_
- How algebras were used to model domains in a neat way and how it was adequate to the pure functional programming approach
- How creating new data types was done by using an _algebra_ composed by types and operations on them and thus why the type created that were called _algebraïc data types_

I'll try to keep that blog post updated.
If there are any additions, imprecision or mistakes that I should correct or if you need more explanations, feel free to contact me on Twitter or by mail !