---
layout: post
title: "Anatomy of functional programming"
author: "Myself"
date: 2018-10-06
catorgories: [anatomy-atlas]
tags: [Scala, Functional programming]
---

I will try to group here, in an anatomy atlas, basic notions of functional programming that I find myself explaining often lately into a series of articles.

The idea here is to have a place to point people needing explanations and to increase my own understanding of these subjects by trying to explain them the best I can.
I'll try to focus more on making the reader feel an intuition, a feeling about the concepts rather than on the perfect, strict correctness of my explanations.

- Part 1: [Anatomy of functional programming]() - Yet to come !
- Part 2: [Anatomy of an algebra]({{ site.baseurl }}{% post_url 2018-10-06-algebras %})
- Part 3: [Anatomy of a type class]({{ site.baseurl }}{% post_url 2018-10-05-typeclasses %})
- Part 4: Anatomy of semi groups and monoids - Yet to come !
- Part 5: Anatomy of functors, applicatives and monads - Yet to come !
- Part 6: Anatomy of the tagless final encoding - Yet to come !

# What is functional programming ?

## A general definition

To begin our _anatomy atlas of functional programming constructs_, the first question to answer is: _what is functional programming ?_

The way I would define it would be:

> A style of programming which aim to avoid all _side effects_ by using, until the end of the world, _pure functions_ that manipulate immutable data.

What we call the _end of the world_ here is a way to refer at your main function.

The definition we gave for functional programming introduced the notions of _side effects_, _pure functions_ and _immutable data_ that we are going to explain.

## Side effects

A function should have only one effect: the effect of computing its return value. Any other effects triggered by that function are _side effects_ (logging, printing, IOs, and so on.)

## Pure functions

_Pure functions_ are somehow a computational analogy of mathematical function, they are functions have to respects a set of simple rules:

- _Determinism_: a _pure function_ will always return the same output when given the same inputs, they does not use non local variable, global mutable states, perform IO, and so on

    - `def add(a: Int, b: Int): Int = a + b` is determinist, it will always return the same output value when given the same input values
    - `def rand(a: Int): Int = Random.nextInt(a)` is not, each call may return different return values

- _Totality_: a _pure function_ from type `A => B` (`A` is called the domain and `B` the co-domain), has to be defined (must "work and return a value") for every values of type `A`

    - `def divide(a: Int, b: Int): Int = a / b` is not total, it will crash if `b == 0`
    - `def safeDivide(a: Int, b: Int): Option[Int] = Try(a / b).toOption` is total by handling undefined case with `None`

- _Referential transparency_: a _pure function_ should be replacable by its result anywhere it is used without altering the rest of the program

    ```scala
    def launchTheMissiles: Unit = ???
    def formattingMyStuff(s: String): String = {
        launchTheMissiles
        s.toUpperCase
    }
    ```

    - Here we cannot replace any calls to `formattingMyStuff` without altering the rest of the program, because `formattingMyStuff` performs a side effect, `launchTheMissiles` so we have no garanties that calling `formattingMyStuff` will not have any other effects than returning its lowercased argument.
    - With `def purelyFormattingMyStuff(s: String): String = s.toUpperCase` howerver, any call to it could be replaced direcly by the lowercased argument and we know that the program would work the same way it did before
    - To go even further, a _referentialy transparent_ function should be replacable by a lookup table associating directly its inputs with its output

        - `def boolToString(b: Boolean): String = if (b) "That's true !" else "That's wrong..."` should be replacable by the following lookup table:

        Input | Output
        --- | ---
        `true` | "That's true !"
        `false` | "That's wrong..."

## Immutable data

That one is simple, a _value_ (note I didn't use the term _variable_ here) is said to be immutable if, once evaluated, there is no way to change it.

- That one is mutable, and thus, won't be used in functionnal programming

```scala
var meaningOfLife = 41
meaningOfLife = meaningOfLife + 1
```

- That one is not:

```scala
val meaningOfLife = 42
meaningOfLife = meaningOfLife + 0
//<console>:12: error: reassignment to val
//       meaningOfLife = meaningOfLife + 0
```

## Benefits of FP

For now, what we saw about FP was more or less only constraints.

But functional programming shouldn't be only seen a lists of constraints, as [Runar Bjarnason](Constraints Liberate, Liberties Constrain â€” Runar Bjarnason) would say, constraints buy you a lot of freedom.

That may not seem obvious but I'll try to explain why.

__Functional programming is about reducing the number of moving pieces the your code.__

### Equationnal reasoning

_Pure functions_, while being restrictives allows you to reason about your program in a way that would not be possible otherwise, it is called _equational reasoning_.

It means that, once you figure out that `f(x) = something`, then everywhere `f(x)` appears, you won't have to do anything more than replacing it by `something`.

_Equationnal reasoning_ allows you to follow the logic of your program by replacing your function calls by their results, exactly how you'd do when trying to solve a mathematical equation:

- If you had these two equations:

    ```
    2x - 3y  = 12
    y + 2x   = 180
    ```

- Then you could isolate `x` the the first one:

    ```
    2x - 3y = 12
    2x      = 12 + 3y
    x       = (12 + 3y ) / 2
    ```

- And then simply __replace__ `x` in the rest of your reasonning by its value:

    ```
    y + 2x                  = 180
    y + 2 * (12 + 3y) / 2   = 180
    y + 12 + 3y             = 180
    4y                      = 168
    y                       = 42
    ```

That's a powerfull way to reason about complex problems. Without pure function, you would have to keep a mental track of what's going on.

### Predictable data

As you data is immutable, it is easier to keep track of its state, since __its state doesn't change__.
The only way to create data is by using its construtor (in the broad sense) and that, also, reduce a lot your software's moving parts.

You know for sure that, when using a piece of data, it has not been modified in the meantime by something else, you can rely on it.

> If you isolate the places where changes occur by severely restricting mutation, you create a much smaller space for errors to occur and have fewer places to test.
([Neal Ford](https://www.ibm.com/developerworks/library/j-ft4/index.html))

Morever, it give you _thread safety by desgin_, your data will never be in an unknown or undesirable state, which is huge in our more and more concurrent applications.

### Playing with Lego

You are garantied that a piece of your software is only:

- Taking inputs
- Computing an output value
- Returning it
- And does __nothing__ else than that

How could it be easier to replace that piece ?

Wheb each functions of your software are tiny black boxes that don't lie about what they trully do, replacing one by another becomes absolutly trivial.

### Easy to test

### Playing lego

### Crystalising design patterns