# Qu'est ce que la programmation fonctionnelle ?

## Une d√©finition g√©n√©rale

Pour commencer, la premi√®re question √† se poser est: _qu'est ce que la programmation fonctionnelle ?_

__L'objectif global de la programmation fonctionnel est de r√©duire, tant que possible, les parties mouvantes et dangereuses de votre programme.__

Je la d√©finirais comme:

> Un paradigme, une fa√ßon de programmer, qui vise √† √©viter, autant que possible, les _effets de bords_ en utilisant le plus possible des _fonctions pures_ manipulant des donn√©es _immuables_.

Ainsi, la majeure partie de votre base de code (id√©alement la totalit√© √† part votre _main_) est dite "_pure_" et de des propri√©t√©s int√©ressantes en d√©coulent comme nous allons le voir. 

Si votre _main_ est la seule partie  "_impure_", vous avez d√©j√† drastiquement r√©duit la portion la plus dangereuse de votre code.

La d√©finition de la _programmation fonctionnelle_ que j'ai donn√© tout √† l'heure introduit les termes _effets de bord_, _fonctions pures_ ou _donn√©es immuables_ que je vais maintenant expliquer.

## Effets de bord

Une fonction ne devrait avoir qu'un seul effet: celui de calculer la valeur qu'elle renvoie.

Tout autre effet d√©clench√© par une fonction est un _effet de bord_ (g√©n√©rer une exception, logger, afficher quelque chose √† l'√©cran, √©crire sur disque, √©changer sur le r√©seau, etc.).

La _programmation fonctionnelle_ n'interdit ces actions, mais elle encourage √† les faire de fa√ßon de fa√ßon _explicite_, plut√¥t que secr√®tement, cach√© au sein de fonctions qui ne d√©clarent pas haut et fort r√©aliser ces effets de bords.

## Fonctions pures

_Les fonctions pures_ sont ce qui se rapprocherait le plus des fonctions math√©matiques.

### R√®gles de puret√©

Une fonction, pour √™tre pure, doit respecter un certain nombre de r√®gles simples:

- _D√©terminisme_: _une fonction pure_ √† laquelle on donne __les m√™mes entr√©es donnera toujours la m√™me sortie, sans autre impacts sur le programme__. En cons√©quence, elle ne peut utiliser de variables globales, d'√©tats mutables, d'I/O, etc.

    - `def add(a: Int, b: Int): Int = a + b` est d√©terministe, elle renverra toujours la m√™me sortie si on lui envoie les m√™mes entr√©es
    - `def rand(a: Int): Int = Random.nextInt(a)` ne l'est pas, chaque appel peut recevoir un retour diff√©rent
    - Une fonction retournant `Unit` devrait √™tre un __√©norme indice de mauvais design__. Cette fonction ne revoie _"rien"_, sa seule utilit√© doit donc √™tre de produire des effets de bord. C'est le N√©m√©sis du d√©terminisme !

- _Totale_: une _fonction pure_ de type `A => B` (`A` est appel√©e le _domaine_ de la fonction et `B` le _co-domaine_) __doit √™tre d√©finie pour toute les valeurs de son domaine__, ici pour les valeurs de type `A`.

    - `def divide(a: Int, b: Int): Int = a / b` n'est pas totale, le programme plante pour `b == 0`
    - `def safeDivide(a: Int, b: Int): Option[Int] = Try(a / b).toOption` est totale car il g√®re le cas limite par le renvoi de `None` pour `b == 0`

- _Transparence r√©f√©rentielle_: la transparence r√©f√©rentielle s'applique non seulement aux fonctions mais aussi √† un programme plus vaste, car, pour une fonction seule, la transparence r√©f√©rentielle revient au d√©terminisme vu plus haut. Un programme r√©f√©rentiellement transparent __doit √™tre enti√®rement rempla√ßable par le r√©sultat que donne son √©valuation__ m√™me si celui-ci est partie int√©grante d'un autre programme plus vaste et __sans alt√©rer le reste de ce programme__.

    ```scala
    def launchTheMissiles: Unit = ???
    def formattingMyStuff(s: String): String = {
        launchTheMissiles
        s.toUpperCase
    }
    ```

    - Ici on ne peut pas remplacer l'appel `formattingMyStuff("hi")` par `"HI"` sans alt√©rer le reste du programme, car `formattingMyStuff` effectue un _effet de bord_, `launchTheMissiles`. Si l'on remplace `formattingMyStuff("hi")` par `"HI"`, les missiles ne seront pas lanc√©s. L'appel `formattingMyStuff("hi")` n'est pas r√©f√©rentiellement transparent.
    - Avec `def purelyFormattingMyStuff(s: String): String = s.toUpperCase` en revanche, tout appel peut √™tre remplac√© directement par l'argument pass√© en majuscule, et l'on sait que le reste du programme n'en sera pas alt√©r√©
    - Pour enfoncer le clou, un code _r√©f√©rentiellement transparent_ doit √™tre rempla√ßable par une table de correspondance argument(s) / r√©sultat qui ferait correspondre automatiquement le ou les arguments √† leur r√©sultat associ√©

        - `def boolToString(b: Boolean): String = if (b) "That's true !" else "That's wrong..."` est _r√©f√©rentiellement transparente_. Elle est rempla√ßable par la table de correspondance suivante, sans aucune alt√©ration pour le reste du programme:

        Input | Output
        --- | ---
        `true` | "That's true !"
        `false` | "That's wrong..."

En comprenant bien ces r√®gles, vous pouvez vous rendre compte comment, en utilisant des fonctions qui les respectent, vous r√©duisez consid√©rablement les pi√®ces mouvantes de votre programme. 
__Ces fonctions font ce que leurs signatures annoncent, et elle ne font que √ßa.__


### Comment fait-on de "vraie choses" alors ?


Les seuls effets que peuvent avoir les fonctions sont d'allouer de la m√©moire et du temps de processeur pour calculer leurs r√©sultats de retour et rien d'autre ?

Sans la possibilit√© de faire des entr√©es / sorties, d'utiliser de l'al√©a ou encore de rater, r√©aliser des programmes utiles s'annonce compliqu√©...

√âvidement, la _programmation fonctionnelle_ vous permet de faire tout √ßa, elle demande juste √† ce que cela soit fait de fa√ßon __explicite__.

Voici quelques exemples:

- Une fonction retournant un `Option[Int]` retourne en fait juste un `Int` mais ce type de retour ajoute explicitement √† la fonction l'__effet__ de pouvoir rater, de ne pas √™tre capable de renvoyer un `Int`, et de renvoyer `None` √† la place.
- Une fonction qui retourne un `Either[String, Int]` retourne en fait juste une `Int`, mais ajoute l'__effet__ de renvoyer un `String` qui pourrait, par exemple, repr√©senter la raison pour laquelle elle n'a pas pu retourner un `Int` (ce n'est pas la seule utilisation d'`Either`).
- Une fonction retournant un `Task[Int]` ou `IO[Int]`, etc. __renvoie la liste des √©tapes √† suivre, sans pour autant les avoir d√©j√† ex√©cut√©es, qui produiront un `Int` (ou ratera), √† terme, une fois ex√©cut√©es__. C'est la __description__ d'un effet qui n'a pas encore eu lieu et non pas l'effet lui m√™me.
- Beaucoup d'effets sont donc encod√©s de cette mani√®re et aller plus en d√©tail serait l'objet d'un article √† part (vous pouvez trouver beaucoup de ressource en relation [ici](https://github.com/mmenestret/fp-ressources/blob/master/README.md))

## Philosophie de la donn√©e

### Relation donn√©e / comportement

_La programmation orient√© objet (OOP)_ et la _programmation fonctionnelle (FP)_ ont deux approches diff√©rentes de la relation entre la donn√©e et les comportements sur cette donn√©e:

- _L'OOP_ a tendance √† combiner la donn√©e et les comportements au sein de _classes_ qui:
    - Stockent et cachent la donn√©e sous forme d'√©tat interne mutable
    - Exposent publiquement des m√©thodes qui permettent d'agir dessus et de la transformer

```scala
case class Player(nickname: String, var level: Int) {
    def levelUp(): Unit          = { level = level + 1 }
    def sayHi(): String          = s"Hi, I'm player $nickname, I'm lvl $level !"
}
```

- _La FP_ vise √† __s√©parer compl√®tement la donn√©e des comportements__ en:
    - D√©finissant des types ([ADT](http://geekocephale.com/blog/2018/10/06/algebras) d'un c√¥t√©, qui n'exposent aucun comportements, mais uniquement de la donn√©e
    - Des fonctions, qui prennent des valeurs en arguments et renvoient des valeurs sans avoir chang√© les valeurs d'entr√©e au passage

```scala
case class Player(nickname: String, level: Int)

object PlayerOperations {
    def levelUp(p: Player): Player = p.copy(level = p.level + 1)
    def sayHi(p: Player): String   = s"Hi, I'm player ${p.nickname}, I'm lvl ${p.level} !"
}
```

### L'_expression problem_

L'_expression problem_ est souvent utilis√© pour d√©crire comment un langage ou un paradigme se comporte lorsqu'il s'agit d'ajouter √† une base de code d√©j√† existante:

- De nouveaux repr√©sentants √† des types existant
- De nouveaux comportements √† des types existant

Et s'ils parviennent √† le faire sans avoir √† toucher au code existant.

L'id√©e derri√®re l'_expression problem_ est de permettre de comparer la fa√ßon dont les langages ou les paradigmes r√©pondent √† ce genre de probl√©matique.

L'_OOP_ et la _FP_ ont tout deux des fa√ßons diff√©rentes de r√©pondre √† ces probl√®mes.

#### _Paradigme de l'OOP_

- üëç : Ajouter de nouveaux repr√©sentant √† un type d√©j√† existant
    - Une nouvelle _classe_ _√©tendant_ la _classe / interface_ existante
- üëé : Ajouter de nouveaux comportements √† un type existant
    - Une nouvelle _m√©thode_ doit √™tre ajout√©e sur la _super classe ou interface_ appropri√©e, ce qui impacte l'impl√©mentation de toutes les _sous classes_

Exemple de code existant:

```scala
trait MyType { def behavior: String }

final case class A() extends MyType { override def behavior: String = "I'm A" }
final case class B() extends MyType { override def behavior: String = "I'm B" }
```

Ajouter un nouveau repr√©sentant √† un type existant (`MyType`) 

```scala
final case class C() extends MyType { override def behavior: String = "I'm C" }
```

Ajouter un nouveau comportement √† un type existant (`MyType`)

```scala
trait MyType { 
    def behavior: String
    def newBehavior: String
}
```

Il faut maintenant repasser sur toutes les classes √©tendant `MyType` pour impl√©menter `newBehavior`.

#### _Paradigme FP_

- üëç : Ajouter de nouveaux repr√©sentant √† un type d√©j√† existant
    - Ajouter un nouveau repr√©sentant √† un _sum type_ (cf: [Anatomy of an algebra](http://geekocephale.com/blog/2018/10/06/algebras)) impacte toutes les fonctions acceptant ce type en entr√©e (il faut impl√©menter le comportement pour ce nouveau type).
- üëé : Ajouter de nouveaux comportements √† un type existant
    - Une nouvelle fonction, rien de plus.

Exemple de code existant:

```scala
sealed trait MyType
final case class A() extends MyType
final case class B() extends MyType

def behavior(m: MyType): String = m match {
    case A() ‚áí "I'm A"
    case B() ‚áí "I'm B"
}
```

Ajouter un nouveau repr√©sentant √† un type existant (`MyType`) 

```scala
final case class C() extends MyType
```
Maintenant il faut revenir sur toutes les fonctions prenant en entr√©e une donn√©e de type `MyType` pour en impl√©menter le nouveau comportement.

Ajouter un nouveau comportement √† un type existant (`MyType`)

```scala
def newBehavior(m: MyType): String = m match {
    case A() ‚áí ???
    case B() ‚áí ???
  }
```

### Donn√©e immuable

C'est tr√®s simple, une donn√©e est dite immuable si, une fois √©valu√©e, il n'y a aucun moyen d'en changer la valeur.

- Voici de la donn√©e _mutable_ dont l'utilisation doit √™tre √©vit√©e en _programmation fonctionnelle_:

```scala
var meaningOfLife = 41
meaningOfLife = meaningOfLife + 1
```

- Voici de la donn√©e _immuable_:

```scala
val meaningOfLife = 42
meaningOfLife = meaningOfLife + 0
//<console>:12: error: reassignment to val
//       meaningOfLife = meaningOfLife + 0
```

S'il vous est impossible de ne pas utiliser de donn√©e mutable, par exemple pour des raisons d'optimisation fine, je vous encourage √† le faire avec pr√©caution et en isolation, dans un cadre ma√Ætris√©, encapsul√© dans une construction immuable:

```scala
val magic = {
    var mutableMagic = 0
    mutableMagic = mutableMagic + 42
    mutableMagic
}
```

Ainsi vous √™tes sur que la mutabilit√© ne se r√©pandra pas au del√† du cadre impos√© et n'ajoutera pas une pi√®ce mouvante, sans contraintes, √† votre programme.

# Int√©r√™ts de la programmation fonctionnelle

Pour l'instant, nous n'avons vu quasiment que des contraintes...

La _programmation fonctionnelle_ n'est pas qu'une suite de contraintes sans but, mais comme l'explique [Runar Bjarnason](https://www.youtube.com/watch?v=GqmsQeSzMdw), contraindre vos impl√©mentations vous offrent beaucoup de libert√©s par la suite.

Cela peut para√Ætre contre-intuitif mais je vais vous expliquer pourquoi.

## Raisonnement √©quationnel

Les _fonctions pures_, bien que restrictives vous permettent de raisonner √† propos de vos programmes d'une fa√ßon qui serait impossible autrement. C'est ce que l'on appelle le raisonnement √©quationnel.

Cela signifie qu'une fois d√©termin√© que `f(x)`, √©valu√©, vaut `y`, vous pouvez simplement remplacer par `y` toutes occurrences de `f(x)` dans votre programme et r√©duire ainsi la complexit√© de votre raisonnement sans avoir √† r√©√©valuer `f(x)` √† chaque fois.

_Le raisonnement √©quationnel_ vous permet de suivre la logique d'un programme en rempla√ßant, au fur et √† mesure, les appels aux fonctions par leurs r√©sultats, en r√©duisant la charge cognitive que repr√©sente le parcours de ce code, comme on le ferait lors de la r√©solution d'une √©quation math√©matique:

- Si vous aviez ces √©quations:

    ```
    2x - 3y  = 12
    y + 2x   = 180
    ```

- Vous pouvez isoler `x` dans la premi√®re √©quation:

    ```
    2x - 3y = 12
    2x      = 12 + 3y
    x       = (12 + 3y ) / 2
    ```

- Puis simplement __remplacer__ `x` dans le reste pour raisonner simplement sur les autres √©quations:

    ```
    y + 2x                  = 180
    y + 2 * (12 + 3y) / 2   = 180
    y + 12 + 3y             = 180
    4y                      = 168
    y                       = 42
    ```

C'est une fa√ßon tr√®s puissante de raisonner √† propos de probl√®mes complexes.


Sans la _transparence r√©f√©rentielle_, il faudrait analyser chaque appels de fonction, v√©rifier ce que font ces fonctions en plus de renvoyer leurs r√©sultats, garder ces effets suppl√©mentaires en t√™te, et continuer votre analyse sans les perdre de vue au risque de fausser le raisonnement.

C'est un bon exemple d√©montrant comment des contraintes peuvent vous donner des libert√©s en contrepartie.

## De la donn√©e pr√©dictible

Comme votre donn√©e est _immuable_, il est beaucoup plus simple d'en garder la valeur en t√™te, puisque __cette valeur ne change pas__.

La seul fa√ßon de cr√©er la donn√©e et d'utiliser le constructeur du type (au sens large), ainsi, √† nouveau, _cela permet de r√©duire les parties mouvantes de votre programme_.

Vous pouvez √™tre s√ªr, en utilisant de la donn√©e, que celle-ci n'a pas √©t√© modifi√©e depuis un autre endroit, vous pouvez l'utiliser sans risque.

> Si isolez les endroits o√π les changements de donn√©e peuvent avoir lieu en restreignant s√©v√®rement la mutabilit√©, vous cr√©ez un espace beaucoup plus restreint dans lequel de potentielles erreurs peuvent arriver, et vous aurez moins d'endroits √† tester.
([Neal Ford](https://www.ibm.com/developerworks/library/j-ft4/index.html))

De plus, cela permet d'obtenir la _thread safety_ par design, comme votre donn√©e ne sera jamais dans un √©tat inconnu ou ind√©sirable, et c'est un √©norme avantage dans nos contextes de plus en plus concurrentes.

## Jouer avec des Lego

En plus du _raisonnement √©quationnel et de l'immuabilit√©_, je vais essayer de vous montrer ce que la _FP_ apporte de plus √† votre code avec une analogie.

Vous souvenez-vous de vos Lego ? La _FP_ permet de jouer avec votre code de la m√™me qu'avec avec vos blocs de Lego.

Vous aviez plusieurs blocs, tous n'allaient pas forc√©ment ensemble, ils √©taient solides, immuables et remplissaient tous un r√¥le unique.

Exactement comme le sont les _fonctions pures_ et les _donn√©es immuables_.


Cela vous permet:

- De refactorer vos applicatifs sans heurts

    - Vous savez que vous pouvez changer ce bloc rouge par ce bleu, si il respecte le m√™me contrat et qu'il n'impacte pas, d'une fa√ßon ou d'une autre le reste de votre construction (effets de bord, mutabilit√©, ...)

- Composabilit√©

    - Vous pouvez cr√©er une construction d'un c√¥t√©, une autre construction d'un autre, puis les assembler pour obtenir une construction nouvelle plus complexe qui se comporte comme vous l'attendiez en assemblant les deux parties ind√©pendantes
    - C'est exactement ce que vous pouvez faire avec des _fonctions pures_. Vous connaissez les entrants, vous savez qu'elle ne font __rien d'autre__ que produire des sortant que vous pouvez √† nouveau passer √† de nouvelles _fonctions pures_. Vous pouvez donc les composer et cr√©er de la complexit√© sans craintes !

- Une meilleure testabilit√©
    
    - Vous pouvez beaucoup plus facilement tester une pi√®ce quand vous savez √† coup s√ªr, que ce n'est qu'une pi√®ce simple, ind√©pendante, sans effets de bord


## La programmation fonctionnelle cristallise les design patterns

Pour en finir avec les avantages de la _programation fonctionnelle_, il existe cette chose curieuse appel√©e [_correspondance de Curry‚ÄìHoward_](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence) qui est un lien direct entre la _logique math√©matiques_ et le _calcul computationnel_ (ce que nous faisons, nous, programmeurs).

Cette correspondance signifie, dans les grandes lignes, que beaucoup de concepts d√©couverts et d√©montr√©s en _math√©matiques_ depuis des d√©cennies peuvent √™tre transpos√©s √† la programmation (et vice versa), offrant √©norm√©ment de nouveaux outils de mod√©lisation, gratuitement !

En _OOP_, les _design patterns_ sont √©norm√©ment utilis√©s et peuvent √™tre d√©finis comme des _fa√ßons idiomatiques de r√©soudre des probl√®mes dans des contextes sp√©cifiques_ mais leurs existences ne vous sauveront pas d'avoir √† les appliquer, les r√©impl√©menter, encore et encore, √† chaque fois que vous rencontrerez les probl√®mes qu'ils r√©solvent.

Les constructions de la _programmation fonctionnelle_, certains provenant directement de la _th√©orie de cat√©gorie_ (math√©matiques), r√©solvent directement, par nature, ce que vous auriez essay√© de r√©soudre √† travers des design patterns bien connus.

La bo√Æte √† outils classique de la _programmation fonctionnelle_ vous donne des constructions, des structures de donn√©es, permettant de g√©rer, sans douleurs:

- Les √©tats globaux
- La concurrence
- La parall√©lisation
- Les √©checs de computation / exceptions
- Les validations cumulative
- L'asynchronisme
- La s√©quentialit√©
- Les combinaisons associatives
- ...

Vous trouverez ici une liste de comment les constructions de la _programmation fonctionnelle_ correspondent au design patterns classiques: [Lambda, the ultimate pattern factory](https://github.com/thma/LtuPatternFactory).

Plut√¥t pratique !

# Des ressources !

Si vous souhaitez creuser, voici une liste de ressources int√©ressantes, qui peuvent √™tre trouv√©es sur ma [liste de ressources autour de la programmation fonctionnelle](https://github.com/mmenestret/fp-ressources) et en particulier:

- [What Referential Transparency can do for you - Luka Jacobowitz](https://www.youtube.com/watch?v=X-cEGEJMx_4&feature=youtu.be&t=228)
- [Constraints Liberate, Liberties Constrain ‚Äî Runar Bjarnason](https://www.youtube.com/watch?v=GqmsQeSzMdw)
- [Functional Design Patterns - Scott Wlaschin](https://www.youtube.com/watch?v=srQt1NAHYC0)
- [Propositions as Types - Philip Wadler](https://www.youtube.com/watch?v=IOiZatlZtGU)

# Conclusion

Pour r√©sumer, nous avons vu:

- Ce qu'est vraiment la __programmation fonctionnelle__ et que cela signifie de manipuler de la donn√©e __immuable__ et des __fonctions pures__
- Nous avons vu plus en d√©tails ce que sont les _effets de bord_, les _fonctions pures_ et l'_immuabilit√©_.
- Les libert√©s que nous offre les contraintes impos√©s par la _FP_ (raisonnement √©quationnel, pr√©dictibilit√©, refactoring, testabilit√©, etc.)
- Qu'il existe un pont entre le monde de la _logique math√©matiques_ et de la _computation_ et comment celui-ci nous fournit gratuitement des constructions tr√®s utiles
- Comment certaines de ces constructions nous permettent de tacler des probl√®mes du quotidien que nous aurions, sinon, r√©solus gr√¢ce √† des designs patterns lourds et redondant
